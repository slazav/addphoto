#!/usr/bin/perl

use strict;
use warnings;
use Getopt::Long;
use Digest::MD5;

#################################################################
### Commands
my %cmds = (
  help             => 0,
  init             => 0,
  init_only        => 0,
  opts             => 0,
  defs             => 0,
  expand           => '',
  cleanup          => 0,
  index_only       => 0,
);

#################################################################
### Options
my %opts = (
  verbose          => 0,
  imgdir           => '',
  datadir          => '',
  cfg              => '',
  ph_resize        => 'ph_resize',
  html             => '',
  html_filter      => '',
  html_stdout      => 0,
  init_tsort       => 1,
  init_days        => 1,
  init_rec         => 0,
  page_width       => 800,
  init_img_mask    => '(.jpe?g$)|(.png$)|(.tiff?$)|(.gif)$',
  force            => 0,
  dryrun           => 0,
  th1_pref         => '_',
  th1_size         => '260:160:800',
  th1_rm_exif      => 1,
  th2_pref         => '',
  th2_size         => '800:600:1600',
  th2_rm_exif      => 1,
  mark_pref        => '_',
  html_pref        => '',
  nohtml           => 0,
  mstyle           => 'aa_gif',
  lang             => 'select',
  quality          => 90,
  map_ref          => 'nakarte',
  map_zoom         => 13,
  fig_lang         => 'ru_RU.KOI8-R',
  fig_res          => 14.2875, # convert pixel -> fig units
  html_headers     => 1,
  html_charset     => 'koi8-r',
  html_viewport    => 1,
  html_screen_sw   => 1,
  html_arrows      => 1,
  html_resize      => 1,
  index            => 0,
);
Getopt::Long::Configure("no_ignore_case");
Getopt::Long::GetOptions(
  "h|help"          => \$cmds{help},         # print help message
  "I|init=s"        => \$cmds{init},         # INIT MODE: create source file. Argument - folder
  "J|init_only=s"   => \$cmds{init_only},    # create source file and exit. Argument - folder
  "O|opts"          => \$cmds{opts},         # read file, print options and exit
  "D|defs"          => \$cmds{defs},         # read file, print definitions and exit
  "E|expand=s"      => \$cmds{expand},       # Expand variables in a string
  "C|cleanup"       => \$cmds{cleanup},      # CLEANUP MODE: remove unused files and exit
  "index_only:1"    => \$cmds{index_only},   # stop after updating index

  "v|verbose:1"     => \$opts{verbose},      # be verbose
  "c|cfg=s"         => \$opts{cfg},          # config file, .addphoto.cfg or addphoto/addphoto.cfg if empty
  "imgdir=s"        => \$opts{imgdir},       # image dir, relative to source file location, default input file name without last extension
  "datadir=s"       => \$opts{datadir},      # data dir (relative to source file location, default: same as imgdir)
  "ph_resize=s"     => \$opts{ph_resize},    # path to ph_resize script (default: ph_resize)
  "H|html=s"        => \$opts{html},         # html file (relative to source file location)
  "html_filter=s"   => \$opts{html_filter},  # filter for source html
  "html_stdout:1"   => \$opts{html_stdout},  # print source html to stdout instead of writing to file. html option is still needed.
  "T|init_tsort:1"  => \$opts{init_tsort},   # init mode: sort photos by time
  "d|init_days:1"   => \$opts{init_days},    # init mode: add day headers
  "r|init_rec:1"    => \$opts{init_rec},     # init mode: find files recursively
  "w|page_width=i"  => \$opts{page_width},         # max page width (init mode, body max-width property)
  "init_img_mask=s" => \$opts{init_img_mask},      # init mode: mask for finding images
  "f|force:1"       => \$opts{force},        # cleanup mode: do not ask before deleting files
  "dryrun:1"        => \$opts{dryrun},       # cleanup mode: do not delete files
  "th1_pref=s"      => \$opts{th1_pref},     # Small thumbnail prefix (can end with /), empty for no thumbnails
  "th1_size=s"      => \$opts{th1_size},     # Small thumbnail size (S1:S2:S3, see elsewhere)
  "th1_rm_exif:1"   => \$opts{th1_rm_exif},  # Remove exif-data from small thumbnails (default)
  "th2_pref=s"      => \$opts{th2_pref},     # Large thumbnail prefix (can and with /), empty for no thumbnails
  "th2_size=s"      => \$opts{th2_size},     # Large thumbnail size (S1:S2:S3, see elsewhere)
  "th2_rm_exif:1"   => \$opts{th2_rm_exif},  # Remove exif-data from large thumbnails (default)
  "mark_pref=s"     => \$opts{mark_pref},    # Image marks prefix (can and with /), empty for no marks
  "html_pref=s"     => \$opts{html_pref},    # Image marks prefix (can and with /), empty for no marks
  "nohtml:1"        => \$opts{nohtml},       # Do not generate hmtl pages for images
  "mstyle=s"        => \$opts{mstyle},       # Mark style
  "l|lang=s"        => \$opts{lang},         # Language (ru, en, select)
  "quality=i"       => \$opts{quality},      # Jpeg quality for thumbnails (default 90)
  "map_ref=s"       => \$opts{map_ref},      # Map link style (gmap, nakarte)
  "map_zoom=i"      => \$opts{map_zoom},     # Map link zoom (default 6)
  "fig_lang=s"      => \$opts{fig_lang},     # fig language
  "fig_res=f"       => \$opts{fig_res},      # fig resolution
  "html_headers:1"  => \$opts{html_headers}, # generate html headers in the source file
  "html_charset=s"  => \$opts{html_charset}, # add meta charset tag in html pages (not in source html)
  "html_viewport:1" => \$opts{html_viewport},# add meta viewport tag in html pages (not in source html)
  "html_screen_sw:1"=> \$opts{html_screen_sw}, # add "fit to screen" switch to html pages
  "html_arrows:1"   => \$opts{html_arrows},  # add navigation (including left/right arrows) to html pages
  "html_resize:1"   => \$opts{html_resize},  # resizable images in html pages (default state of "size" button)
  "index:1"         => \$opts{index},        # use index file (default: do not use index)
) or die "bad option";

my $html_version = '3.0'; # changes when regenerating of html pages is needed

#pod2usage(-exitval => 0, -verbose => 2) if $cmds{help};

# in init mode we can skip source file name, it will be <imgdir>.ph
push @ARGV, $cmds{init} . ".ph"      if ($cmds{init} && @ARGV==0);
push @ARGV, $cmds{init_only} . ".ph" if ($cmds{init_only} && @ARGV==0);
die "Usage: $0 [options] <input file>" unless @ARGV==1;
$opts{imgdir} = $cmds{init} || $cmds{init_only} || $opts{imgdir};

# path to the source file
my $src_path = shift;



#################################################################
#### FILE AND PATH FUNCTIONS

#################################################################
## list all files in the directory.
sub read_dir{
  my @ret;
  my $dir   = shift;         # base dir
  my $rec   = shift || 0;    # recursive?
  my $retdir  = shift || ''; # inclure dir into return?
  unless(opendir D, $dir){
    warn "Skipping unreadable directory: $dir: $!\n";
    return;
  }
  my @list = readdir D;
  closedir D;

  foreach my $f (@list){
    next if $f =~ /^\.{1,2}$/;
    my $df = "$dir/$f";
    push(@ret, $retdir.$f) if (-f $df);
    push(@ret, read_dir($df,$rec,$retdir.$f.'/')) if -d $df && $rec;
  }
  return @ret;
}

## Do we need to update file1 from file2
## (is it older or does not exist)?
sub isolder($$){
  return 0 if (!-r $_[1]);
  return 1 if (!-r $_[0]);
  return (stat $_[0])[9] < (stat $_[1])[9];
}

## split path into full directory name + basename + last extension
## './some/path/file.e1.e2.ext' -> './some/path/' + 'file.e1.e2' + '.ext'
sub path_split($){
  $_[0]=~m&(.*\/)?((.*)(\..*)|(.*)())&;
  return (($1 or ''), ($3 or $5 or ''), ($4 or $6 or ''));
}

## Get relative path from dir1 to dir2.
## Absolute paths, . and .. are ignored!
sub rel_dir($$){
  my @d1 = grep {/.+/ && !/^\.{1,2}$/} split '/', shift;
  my @d2 = grep {/.+/ && !/^\.{1,2}$/} split '/', shift;
  my $n;
  for ($n = 0; $n <= $#d1 && $n <= $#d2; $n++){
    last if ($d1[$n] ne $d2[$n])
  }
  my $ret='';
  $ret .= "../" foreach @d1[$n..$#d1];
  $ret .= "$_/" foreach @d2[$n..$#d2];
  return $ret;
}

#################################################################

# split source file name
my ($src_dir, $src_base, $src_ext) = path_split($src_path);
$src_dir = './' if $src_dir eq '';

# html file name (relative to source file, can be changed later)
$opts{html} = "$src_base.htm" unless $opts{html};
$opts{imgdir}  = $src_base unless $opts{imgdir};
$opts{datadir} = $src_base unless $opts{datadir};

# add trailing / if needed
$opts{imgdir} =~ s/([^\/])$/$1\//;
$opts{datadir} =~ s/([^\/])$/$1\//;

#################################################################
#### IMAGE SIZE FUNCTIONS

## get image size (identify from ImageMagick is needed).
sub image_size($){
  `identify "$_[0]" 2> /dev/null` =~/(\d+)x(\d+)/;
  return ($1 || 0, $2 || 0);
}

## calculate rescaling factor:
# - "Usual" images will be scaled to fit into S1xS1 square;
# - long images will not be smaller then S2 on short edge;
# - very long images will not be larger than S3 on long edge;
# - small images will not be modified.
sub image_scfactor($$$$$){
  my ($x, $y, $m1, $m2, $m3) = @_;
  $x=1.0*$x; $y=1.0*$y;

  my $kx = $x/$m1;
  my $ky = $y/$m1;

  my $k = $kx>$ky ? $kx:$ky;

  $k = $x/$m2 if $x/$k < $m2;
  $k = $y/$m2 if $y/$k < $m2;

  $k = $x/$m3 if $x/$k > $m3;
  $k = $y/$m3 if $y/$k > $m3;

  $k = 1 if $k<=1;
  return $k;
}

## get fig image dimensions in "pixels"
sub fig_im_scale($$){
  my ($figpath, $img) = @_;
  my ($w, $h) = image_size($img);
  $img=~s|.*/||;
  my $fh;
  open $fh, $figpath or return (0,0);
  while (readline $fh){
    next unless (/^\s+\d+\s+$img/);
    readline($fh) =~
      /^\s+([\d-]+)\s+([\d-]+)\s+([\d-]+)\s+([\d-]+)\s+([\d-]+)\s+([\d-]+)\s+([\d-]+)\s+([\d-]+)/;
    my @x=sort($1, $3, $5, $7);
    my @y=sort($2, $4, $6, $8);


    my $fw = abs($x[3]-$x[1])/$opts{fig_res};
    my $fh = abs($y[3]-$y[1])/$opts{fig_res};
    return ($h/$fh + $w/$fw) / 2;
  }
  return 0;
}

#################################################################
#### HTML writing functions


## create table of contents
sub html_toc($$){
  my $fh = shift;
  my $data = shift;
  my $dp=0; # prev depth
  my $d0=0; # initial depth
  my $nh = 0;
  foreach my $b (@{$data}){
    next unless $b->{type} eq 'head';
    $nh++;
    my ($d, $t) = ($b->{depth}, $b->{title});
    if ($dp==$d0){ $dp=$d0=$d-1; }
    for (;$dp<$d;$dp++) {print $fh '  'x($dp-1) . "<ul>\n";}
    for (;$dp>$d;$dp--) {print $fh '  'x($dp-2) . "</ul>\n";}
    print $fh '  'x($d-1) . "<li><a href=\"#h$nh\">$t</a>\n";
  }
  for (;$dp>$d0;$dp--) {print $fh '  'x($dp-2) . "</ul>\n";}
}

#################################################################
#### EXIF functions

## Get exif-data as a hash, convert some values to human-readable form.
## Returns hash ref with original exif fields and some converted fields:
##  dat -- Exif.Photo.DateTimeOriginal or Exif.Image.DateTime,
##  lon, lat, alt -- coordinates, altitude.
## exiv2 program is needed.
sub get_exif{
  my $file=shift;
  my $exif;
  my $n;
  # parse values from exiv2 output.
  foreach (`exiv2 -Pkv "$file" 2>/dev/null`){
    chomp;
    my ($k, $v) = split(/\s+/,$_,2);
    $exif->{$k}=$v if $v && $k;
  }

  my ($time, $alt, $lat, $lon);
  # DateTime: convert 2009:10:20 10:11:12 -> 2009/10/20 10:11:12
  foreach $n ('Exif.Image.DateTime',
              'Exif.Photo.DateTimeOriginal'){
    if ((exists $exif->{$n}) && ($exif->{$n} =~ /^(\d+):(\d+):(\d+)\s+(\d+):(\d+):(\d+)/)){
      $time = "$1/$2/$3 $4:$5:$6"; }
  }

  # convert alt, lat, lon
  $n='Exif.GPSInfo.GPSAltitude';
  if ((exists $exif->{$n}) && ($exif->{$n}=~/^(\d+)\/(\d+)/)){
    $alt = 1.0*$1/$2;
    # $n.Ref can be 0, 1 (invert altitude), 220/100 (xiaomi phones)
    $alt=-$alt if (exists $exif->{$n.'Ref'}) && ($exif->{$n.'Ref'} eq "1");
  }
  $n='Exif.GPSInfo.GPSLatitude';
  if ((exists $exif->{$n}) && ($exif->{$n}=~/^(\d+)\/(\d+)\s+(\d+)\/(\d+)\s+(\d+)\/(\d+)/)){
    $lat = 1.0*$1/$2 + 1.0/60.0*$3/$4 + 1.0/3600.0*$5/$6;
    $lat=-$lat if (exists $exif->{$n.'Ref'}) && ($exif->{$n.'Ref'}=~/^S/);
  }
  $n='Exif.GPSInfo.GPSLongitude';
  if ((exists $exif->{$n}) && ($exif->{$n}=~/^(\d+)\/(\d+)\s+(\d+)\/(\d+)\s+(\d+)\/(\d+)/)){
    $lon = sprintf "%.7f", 1.0*$1/$2 + 1.0/60.0*$3/$4 + 1.0/3600.0*$5/$6;
    $lon=-$lon if (exists $exif->{$n.'Ref'}) && ($exif->{$n.'Ref'}=~/^W/);
  }
  return ($time, $alt, $lat, $lon);
}


#################################################################
#### THUMBNAIL MARKS
## Thumbnail images can is marked with red dot if there are
## some marks on the image. The mark is also kept in the jpeg comment
## These two functions can add and check mark. For remothing mark
## just regenerate thumbnail...
## exiv2 and mogrify (from ImageMagick) programs are needed.
sub thmark_add($$){
  my $f=shift;
  my $c=shift;
  `mogrify -fill $c -draw 'circle 10,10,12,12' "$f"`;
  `exiv2 -c "<marked>" "$f" 2>/dev/null`;
}
sub thmark_check($){
  my $f=shift;
  return -r $f && `exiv2 -pc "$f" 2>/dev/null` =~ /<marked>/;
}

#################################################################
## HTML messages

my %msgs_ru = (
  dat_fmt  => 'Дата и время съемки:',
  alt_fmt  => 'Высота, м:',
  crd_fmt  => 'Координаты:',
  pref     => 'предыдущая (Ctrl-Left)',
  uref     => 'к оглавлению (Esc)',
  nref     => 'следующая (Ctrl-Right)',
  fullsize => 'полный размер',
  sw_size  => 'размер (S или левая кнопка мыши)',
  sw_mark  => 'отметки (M or Enter)',
  sw_imgs  => 'картинки (I)',
  sw_lang  => 'язык (T)',
);

my %msgs_en = (
  dat_fmt  => 'Date and time:',
  alt_fmt  => 'Altitude, m:',
  crd_fmt  => 'Latitude and longitude:',
  pref     => 'previous (Ctrl-Left)',
  uref     => 'up (Esc)',
  nref     => 'next (Ctrl-Right)',
  fullsize => 'full size',
  sw_size  => 'size (S or Left mouse button)',
  sw_mark  => 'marks (M or Enter)',
  sw_imgs  => 'images (I)',
  sw_lang  => 'language (T)',
);

sub get_msg($){
  my $id = shift;
  return "<div class=ru>$msgs_ru{$id}</div><div class=en>$msgs_en{$id}</div>"
    if $opts{lang} eq 'select';
  return $msgs_ru{$id} if $opts{lang} eq 'ru';
  return $msgs_en{$id};
}

## print latlon coords with or without referense to google/nakarte
sub crd_url($$$){
  my ($lat, $lon, $name) = @_;
  my $style = $opts{map_ref};
  my $zoom  = $opts{map_zoom};
  if ($style eq 'gmap'){
    return sprintf('http://maps.google.com?t=h&q=%.7f+%.7f&ll=%.7f,%.7f&z=%d',
                    $lat, $lon, $lat, $lon, $zoom);
  }
  if ($style eq 'nakarte'){
    return sprintf('https://nakarte.me/#m=%d/%f/%f&nktp=%f/%f/%s&l=O',
                    $zoom, $lat, $lon, $lat, $lon, $name);
  }
  return '';
}

## print latlon coords with or without referense to google/nakarte
sub html_crd($$$){
  my ($lat, $lon, $name) = @_;
  my $url = crd_url($lat, $lon, $name);
  if ($url) {return sprintf('<a href="%s">%.7f %.7f</a><br/>',$url, $lat, $lon);}
  return sprintf('%.7f %.7f', $lat, $lon);
}

#################################################################
#################################################################
### Read configuration files
if (!$opts{cfg}){
  foreach ('addphoto.cfg', 'addphoto/addphoto.cfg') {
    if (-f $_){
      $opts{cfg} = $_;
      last;
    }
  }
}
if ($opts{cfg}){
  open CFG, "$opts{cfg}" or die "can't open $opts{cfg}: $!";
  print STDERR "[Reading configuration from $opts{cfg}]\n" if $opts{verbose};
  my $buf = '';
  foreach(<CFG>){
    # comments
    s/#.*//;

    #joining lines
    if (/(.*)\\$/) { $buf .= $1; next; }
    if ($buf){
      s/^\s+/ /;
      $_ = $buf . $_;
      $buf = '';
    }

    # empty lines
    next if /^\s*$/;

    if (/^\s*(\/(.*)\/\s*)?([[:word:]]+)(\s+(.*))?/){
      my ($re, $k, $v) = ($2, $3, $5);
      next if defined($re) && $src_path!~/$re/;
      if (exists $opts{$k}){
        $opts{$k} = $v || '';
      }
      else {
        warn "Unknown configuration option: \"$k\"";
      }
      next;
    }

    warn "Bad configuration line: $_\n";
  }
  close CFG;
}

#################################################################
#################################################################
# INIT call - do source file, then continue as usual
if ($cmds{init} || $cmds{init_only}){

  print STDERR "[Creating source file...]\n" if $opts{verbose};
  die "can't find base folder: $src_dir\n"
    unless -d $src_dir;

  die "can't find image folder: $src_dir$opts{imgdir}\n"
    unless -d "$src_dir$opts{imgdir}";

  ## get image file list
  my @files = grep {/$opts{init_img_mask}/i}
    read_dir("$src_dir$opts{imgdir}", $opts{init_rec});

  ## remove thumbnail, mark, html files from the list
  @files = grep {!/^$opts{th1_pref}.+$opts{init_img_mask}|\/$opts{th1_pref}.+$opts{init_img_mask}/i} @files
    if $opts{th1_pref};
  @files = grep {!/^$opts{th2_pref}.+$opts{init_img_mask}|\/$opts{th2_pref}.+$opts{init_img_mask}/i} @files
    if $opts{th2_pref};
  @files = grep {!/^$opts{mark_pref}.+$opts{init_img_mask}|\/$opts{mark_pref}.+$opts{init_img_mask}/i} @files
    if $opts{mark_pref};

  ## collect information about files: date, time, thumbnail width
  my %files;
  foreach my $file (@files) {
    my $path = "$src_dir$opts{imgdir}$file";

    # get width of small thumbnail (it can be missing!)
    my ($ret, $w, $h) =
      split(/\s+/, `$opts{ph_resize} --scale "$opts{th1_size}" --dryrun --printres "$path" /dev/null`);

    # time from exif
    my ($time,$alt,$lat,$lon) = get_exif($path);

    # day only
    my $date = (split(/\s+/, $time))[0] || '';

    # relative path
    my $p = $file; $p=~s|^$src_dir||; # relative dir

    $files{$file} = {w=>$w, d=>$date, t=>$time, p=>$p};
  }

  rename $src_path, "$src_path.bak" if -f $src_path;
  open OUT, "> $src_path" or die "Can't open $src_path: $!\n";

  print OUT "\\set imgdir $opts{imgdir}\n"
    if $opts{imgdir} ne "$src_base/";


  my $ww=0;  # current width
  my $od=''; # current date

  my @list = (sort keys %files);
  @list = sort {$files{$a}->{t} cmp $files{$b}->{t}} @list if $opts{init_tsort};

  foreach (@list) {
    my $d = $files{$_}->{d};
    my $w = $files{$_}->{w};
    my $p = $files{$_}->{p};

    if ( $od ne $d && $opts{init_days}){
      print OUT "\n\\h4r $d\n";
      $ww=0;
      $od=$d;
    }

    $ww+=$w;
    if ($opts{page_width} && $ww>$opts{page_width}) {
      print OUT "\n";
      $ww=$w;
    }
    print OUT "\\photo $p\n";
  }

  close OUT;
  exit 0 if $cmds{init_only};
}




#################################################################
#################################################################
### Read file, extract photo and header lists, set options.

sub read_file($$$$);


sub expand($$;$){
  my $defs  = shift;
  my $in    = shift;
  my $ch    = shift || '\$';
  # expanding variables
  foreach my $k (keys %{$defs}){
    $in=~s/$ch\{$k\}/$defs->{$k}/g;
    $in=~s/$ch\{$k:\+([^\}]*)\}/$1/g;
    $in=~s/$ch\{$k:\-([^\}]*)\}/$defs->{$k}/g;

  }
  # unset variables
  $in=~s/$ch\{[[:word:]]+\}//g;
  $in=~s/$ch\{[[:word:]]+:\+([^\}]*)\}//g;
  $in=~s/$ch\{[[:word:]]+:\-([^\}]*)\}/$1/g;
  return $in;
}

sub remove_htm($){
  my $in = shift;
  $in=~s/<[^>]*>//g;
  $in=~s/[<>\']//g; #`
  return $in;
}
sub one_lang($$){
  my $in = shift;
  my $keep = shift;
  foreach my $l ('ru','en'){
    next if $keep eq $l;
    $in=~s|<span class=[\"\']?$l[\"\']?>.*?</span>||g;
  }
  return $in;
}

sub expand1($){
  my $in    = shift;
  # Order is important: RU/EN sould not be inside
  # WWW, ONLYRU/ONLYEN should be later, NOHTM should be last.
  $in=~s|(?<![[:word:]])WWW\{(.*?)\}|<a href=$1>$1</a>|gs;
  $in=~s|(?<![[:word:]])RU\{(.*?)\}|<span class=ru>$1</span>|gs;
  $in=~s|(?<![[:word:]])EN\{(.*?)\}|<span class=en>$1</span>|gs;
  $in=~s|(?<![[:word:]])ONLYRU\{(.*?)\}|@{[one_lang($1,'ru')]}|gs;
  $in=~s|(?<![[:word:]])ONLYEN\{(.*?)\}|@{[one_lang($1,'en')]}|gs;
  $in=~s|(?<![[:word:]])NOHTM\{(.*?)\}|@{[remove_htm($1)]}|gs;
  return $in;
}

# read input file
sub read_file($$$$){
  my $fname = shift;
  my $data  = shift;
  my $defs  = shift;
  my $opts  = shift;
  my $ctx='';
  open IN, $fname or
    die "can't open $fname: $!\n";

  my $buf = '';
  foreach(<IN>){

    #joining lines
    if (/(.*)\\$/) { $buf .= $1; next; }
    if ($buf){
      s/^\s+/ /;
      $_ = $buf . $_;
      $buf = '';
    }

    last if /^\\end/;  # stop at \end command
    next if /^\\#/;    # skip comments

    # expanding variables
    $_ = expand($defs, $_);

    if (/^\\photo([lr]?)\s+(\S+)\s*(.*)/){     # images
      die "wrong context for photo command: $ctx" if $ctx ne '';
      my $al = ($1 eq 'r'?'right':($1 eq 'l'? 'left':'center'));
      my $name = $2;
      my $title = $3 || '';
      if ($name=~m|^/| || $name=~m|^\.\.//| || $name=~m|/\.\./|){
        warn "Skip image with non-relative path: $2\n";
        next;
      }
      my @files = split(',', $name);
      push @{$data}, {type=>'photo', files=>[@files], title=>$title, align=>$al};
      next;
    }

    if (/^\\h([1-4])(r?)\s+(.*)/){  # headers
      die "wrong context for header command: $ctx" if $ctx ne '';
      push @{$data}, {type=>'head', depth=>$1, ruler=>($2 eq 'r'), title=>$3};
      next;
    }

    if (/^\\toc/){  # toc command
      die "wrong context for toc command: $ctx" if $ctx ne '';
      push @{$data}, {type=>'toc'};
      next;
    }

    if (/^\\ref\s+(\S+)\s+(.*)/){  # ref command
      die "wrong context for toc command: $ctx" if $ctx ne '';
      push @{$data}, {type=>'ref', name=>$1, text=>$2};
      next;
    }

    if (/^\\keep\s+(.*)/){  # keep command
      push @{$data}, {type=>'keep', globs=>[split('\s+', $1)]};
      next;
    }

    if (/^\\set\s+([[:word:]]+)\s+(.*)/){  # set command
      die "Unknown perameter: $1\n" unless exists $opts->{$1};
      $opts->{$1} = $2;
      next;
    }

    if (/^\\def\s+([[:word:]]+)\s+(.*)/){  # def command
      $defs->{$1} = $2;
      next;
    }

    if (/^\\ifdef\s+(\S+)\s+(.*)/){  # ifdef command
      if (exists $defs->{$1}){ $_="$2\n"; }
      else { next; }
    }

    if (/^\\ifndef\s+(\S+)\s+(.*)/){  # ifndef command
      unless (exists $defs->{$1}){ $_="$2\n"; }
      else { next; }
    }

    if (/^\\ifeq\s+(\S+)\s+(\S+)\s+(.*)/){  # ifndef command
      if ($1 eq $2){ $_="$3\n"; }
      else { next; }
    }

    if (/^\\ifneq\s+(\S+)\s+(\S+)\s+(.*)/){  # ifndef command
      if ($1 ne $2){ $_="$3\n"; }
      else { next; }
    }

    if (/^\\inc\s+(\S+)/){ # include a file
      die "wrong context for include command: $ctx" if $ctx ne '';
      read_file("$src_dir$1", $data, $defs, $opts);
      next;
    }

    if (/^\\ctx(\s+(\S+))?/){ # switch context
      $ctx = defined($2)? $2:'';
      die "unknown context: $ctx"
        unless grep(/^$ctx$/,
          ('', 'head', 'begin', 'end',
               'photo_head', 'photo_begin', 'photo_end', 'none'));
      next;
    }

    if (/^\\[^\\]/){
      warn "warning: skipping unknown command: $_\n";
      next;
    }

    s/^\\// if /^\\\\/; # remove quoted '\'

    # add/append text block
    if ($#{$data}>0 &&
        $data->[$#{$data}]->{type} eq 'text' &&
        $data->[$#{$data}]->{ctx} eq $ctx) {
      $data->[$#{$data}]->{text} .= $_;
    }
    else {
      push @{$data}, {type=>'text', ctx=>$ctx, text=>$_};
    }
  }
}

my %defs = ('SRC_FILE' => $src_base.$src_ext, 'SRC_BASE' => $src_base);
my @data;
read_file($src_path, \@data, \%defs, \%opts);

#################################################################
#################################################################
### recalculate paths (options could be changed in the source file)

# now all configuration should be ready.
# add trailing / if needed
$opts{imgdir}  =~ s/([^\/])$/$1\//;
$opts{datadir} =~ s/([^\/])$/$1\//;

# chech $opts{html} - it should be filename without path!
die "html filename should not contain /\n" if $opts{html} =~/\//;

my $imgdir = $opts{imgdir};
my $datadir = $opts{datadir};
$imgdir  = "$src_dir$imgdir"  unless $imgdir =~ /^\//;
$datadir = "$src_dir$datadir" unless $datadir =~ /^\//;

#################################################################
#################################################################
### Update index.
### We should do it after reading the file where some options can be changed
my %index;

# Read index. Argument - path from source file location or "";
# If file is missing do nothing.
sub read_index($){
  my $idx_path=shift;
  $idx_path  = "$src_dir$idx_path"  unless $idx_path =~ /^\//;
  $idx_path =~ s|^./||g; # strip ./ in the beginning (we use this for keys!)
  my $idx_file = $idx_path.'addphoto.idx';


  if (open(IN, $idx_file)){
    print STDERR "[Reading index: $idx_file]\n" if $opts{verbose};

    my $curr;
    foreach(<IN>){
      next if (/^\s*$/);

      if (/^\* (.*)/){
        my $k = $idx_path.$1;
        $curr = $index{$k} = {HTML=>$k};
        next;
      }

      if (/^\s*([[:word:]]+):\s+(.*)/){
        if ($curr) {
          $curr->{$1} = $2;
        }
        else {
          warn "broken index file, file name is missing before the line: $_\n";
        }
        next;
      }
      warn "skipping bad line in index: $_\n";
    }
    close IN;
  }
}

# Write index. Argument - path from source file location or global path.
sub write_index($){
  my $idx_path=shift;
  $idx_path  = "$src_dir$idx_path"  unless $idx_path =~ /^\//;
  my $idx_file = $idx_path.'addphoto.idx';

  open(OUT, ">", $idx_file) or
    die "can't write index file: $idx_file: $!\n";
  print STDERR "[Writing index: $idx_file]\n" if $opts{verbose};

  foreach my $f (sort keys %index){
    print OUT "* $f\n";
    foreach my $k (sort keys %{$index{$f}}){
      next if $k eq 'HTML';
      print OUT "  $k: $index{$f}->{$k}\n";
    }
  }
  close OUT;
}

if ($opts{index}){
  read_index("");
  $index{$opts{html}} = \%defs;
  write_index("");
}

exit 0 if $cmds{index_only};

#################################################################
#################################################################
# EXPAND call
if ($cmds{expand}){
  my $e = expand(\%defs, $cmds{expand});
  print expand1($e);
  exit 0;
}

#################################################################
#################################################################
# DUMP call - dump options, defs, parsed file and exit
if ($cmds{opts}){
  foreach my $k (sort keys %opts){
    my $v = defined $opts{$k}? $opts{$k}: "undef";
    print "$k: $v\n";
  }
  exit 0;
}

if ($cmds{defs}){
  foreach my $k (sort keys %defs){
    my $v = defined $defs{$k}? $defs{$k}: "undef";
    print "$k: $v\n";
  }
  exit 0;
}

#################################################################
#################################################################
# CLEANUP call - remove unused files in imgdir and exit
if ($cmds{cleanup}){
  my %keep;
  print STDERR "[Cleanup mode...]\n" if $opts{verbose};
  foreach my $b (@data) {
    if ($b->{type} eq 'photo'){
      my @f = @{$b->{files}};
      # add all images
      $keep{"$imgdir$_"} = 1 foreach (@f);

      my ($d, $b, $e) = path_split($f[0]);
      # add html and thumbnail for this image
      $keep{"$imgdir$d$b.htm"} = 1;
      $keep{"$imgdir$d$opts{th1_pref}$b$e"} = 1 if $opts{th1_pref};
      $keep{"$imgdir$d$opts{th2_pref}$b$e"} = 1 if $opts{th2_pref};
      $keep{"$imgdir$d$opts{html_pref}$b.htm"} = 1 unless $opts{nohtml};
      # add mark files
      if ( -f "$imgdir$d$b.fig"){
        $keep{"$imgdir$d$b.fig"} = 1;
        $keep{"$imgdir$d$opts{mark_pref}$b.gif"} = 1 if $opts{th1_pref};
      }
      next;
    }

    # add files from \keep commands
    if ($b->{type} eq 'keep'){
      foreach my $k (@{$b->{globs}}) {
        $keep{$_} = 1 foreach (glob "$imgdir$k");
      }
      next;
    }
  }

  # add source file and html if needed
  if ($opts{imgdir} eq '.') {
    $keep{$src_path} = 1;
    $keep{$src_dir.$opts{html}} = 1;
  }

  # add .js and .css
  if ($imgdir eq $datadir){
    $keep{$_} = 1 foreach (glob "${imgdir}addphoto_*");
  }

  ### get files to delete
  my @del;
  foreach(read_dir($imgdir, 1, $imgdir)){
    push(@del, $_) unless exists($keep{$_});
  }
  exit 0 if $#del<0;

  ### print file list
  if (!$opts{quiet}){
    printf STDERR "Files to remove (%d):\n", $#del+1;
    print STDERR join("\n", sort @del), "\n";
  }

  ### ask question
  if (!$opts{force} && !$opts{dryrun}){
    print STDERR "Remove these files (y|N)? ";
    $opts{dryrun} = 1 unless getc =~ /y/i;
  }

  ### remove files
  if (!$opts{dryrun}){
    printf STDERR "%d files have been removed.\n", $#del+1;
    unlink foreach @del;
  }

  exit 0;
}

#################################################################
#################################################################
# expand functions: RU{}, EN{}, WWW{}
{
  foreach my $b (@data){
    for my $f ('text','title'){
      next unless exists $b->{$f};
      $b->{$f} = expand1($b->{$f});
    }
  }
}


#################################################################
#################################################################
# make add structure
my %add = (
  'head' => '', 'begin' => '', 'end' => '',
  'photo_head' => '', 'photo_begin' => '', 'photo_end' => '',
);
foreach my $b (@data){
  next unless $b->{type} eq 'text';
  $add{$b->{ctx}} .= "$b->{text}"
    if exists($add{$b->{ctx}});
}

# make separate array of photos
my @ph;
foreach my $b (@data){
  push @ph, $b if $b->{type} eq 'photo';
}


#################################################################
#################################################################
### Update files, collect information
print STDERR "[Updating files...]\n" if $opts{verbose};
$opts{_use_marks} = 0;
$opts{_use_multi} = 0;
for (my $i=0; $i<@ph; $i++){
  my $ph = $ph[$i];

  # remove html tags from text, for html alt atribute
  $ph->{atitle} = remove_htm($ph->{title});

  my @files = @{$ph->{files}};
  foreach (@files) {die "error: can't find file: $_\n" unless -f "$imgdir$_";}
  my $f0 = shift @files;

  ## previous and next files:
  my $fp = ${$ph[$i==0? $#ph : $i-1]->{files}}[0];
  my $fn = ${$ph[$i==$#ph? 0 : $i+1]->{files}}[0];

  ## navigation links:
  my ($d0, $b0, $e0) = path_split($f0);
  my ($dp, $bp, $ep) = path_split($fp);
  my ($dn, $bn, $en) = path_split($fn);
  my $purl = rel_dir($d0, $dp) . "$bp.htm";
  my $nurl = rel_dir($d0, $dn) . "$bn.htm";
  my $uurl = rel_dir("$opts{imgdir}/$d0", '')  . "$opts{html}#ph" . ($i+1);

  # files (paths from the image location)
  $ph->{imgname} = "$b0$e0";
  $ph->{figname} = "$b0.fig";
  $ph->{th1name} = "$opts{th1_pref}$b0$e0";
  $ph->{th2name} = "$opts{th2_pref}$b0$e0";
  $ph->{mrkname} = "$opts{mark_pref}$b0.gif";
  $ph->{htmname} = "$opts{html_pref}$b0.htm";

  $ph->{imgdir2img} = $d0;
  $ph->{img2imgdir} = rel_dir($d0, '');
  $ph->{img2datadir} = rel_dir("$opts{imgdir}$d0", $opts{datadir});

  # paths from cwd
  $ph->{imgpath} = "$imgdir$d0$ph->{imgname}";
  $ph->{figpath} = "$imgdir$d0$ph->{figname}";
  $ph->{th1path} = "$imgdir$d0$ph->{th1name}";
  $ph->{th2path} = "$imgdir$d0$ph->{th2name}";
  $ph->{mrkpath} = "$imgdir$d0$ph->{mrkname}";
  $ph->{htmpath} = "$imgdir$d0$ph->{htmname}";
  unlink($ph->{htmpath}) if $opts{nohtml};

  ## do we want to create marks?
  $ph->{_use_marks} = -r $ph->{figpath} && $opts{mark_pref};
  $ph->{_use_multi} = $#files>=0;
  $opts{_use_marks} = 1 if $ph->{_use_marks};
  $opts{_use_multi} = 1 if $ph->{_use_multi};

  ############################################################
  ## update thumbnail image:
  $ph->{use_th1} = $opts{th1_pref} && $opts{th1_size};
  if ($ph->{use_th1}) {
    ## if $opts{th1_pref} is a folder, create it
    mkdir "$imgdir$d0$opts{th1_pref}"
      if $opts{th1_pref} =~ m|/$| && ! -d "$imgdir$d0$opts{th1_pref}";
    ## if th1 file is older then the image OR red mark should be cleaned, update th1
    if (isolder($ph->{th1path}, $ph->{imgpath}) ||
        (thmark_check($ph->{th1path}) && ! $ph->{_use_marks} && !$ph->{_use_multi})){
      print STDERR "  updating thumbnail: " if $opts{verbose};
      `$opts{ph_resize} --scale "$opts{th1_size}" --verbose "$opts{verbose}"\\
         --quality "$opts{quality}" --rm_exif "$opts{th1_rm_exif}" "$ph->{imgpath}" "$ph->{th1path}"`;
    }
    ## add thumbnail mark if needed
    thmark_add($ph->{th1path}, 'red') if $ph->{_use_marks} && !thmark_check($ph->{th1path});
    thmark_add($ph->{th1path}, 'magenta') if $ph->{_use_multi} && !thmark_check($ph->{th1path});
    ## th1 size
    ($ph->{th1_w}, $ph->{th1_h}) = image_size($ph->{th1path});
  }
  else {
    # th1 size is needed for html index even if file does not exist
     my $ret;
    ($ret, $ph->{th1_w}, $ph->{th1_h}) =
      split /\s+/,`$opts{ph_resize} --scale "$opts{th1_size}" --verbose 0 --dryrun "$ph->{imgpath}" /dev/null`;
  }

  ############################################################
  ## update medium-size thumbnail
  $ph->{use_th2} = $opts{th2_pref} && $opts{th2_size};
  if ($ph->{use_th2}) {
    ## if $opts{th2_pref} is a folder, create it
    mkdir "$imgdir$d0$opts{th2_pref}"
      if $opts{th2_pref} =~ m|/$| && ! -d "$imgdir$d0$opts{th2_pref}";
    ## if th2 file is older then the image, update it
    if (isolder($ph->{th2path}, $ph->{imgpath})){
      print STDERR "  updating medium-size image: " if $opts{verbose};
      `$opts{ph_resize} --scale "$opts{th2_size}" --verbose "$opts{verbose}"\\
         --quality "$opts{quality}" --rm_exif "$opts{th2_rm_exif}" "$ph->{imgpath}" "$ph->{th2path}"`;
    }
    ## th2 size
    ($ph->{th2_w}, $ph->{th2_h}) = image_size($ph->{th2path});
  }

  ## image size
  ($ph->{img_w}, $ph->{img_h}) = image_size($ph->{imgpath});

  ## exif data
  ($ph->{time}, $ph->{alt}, $ph->{lat}, $ph->{lon}) = get_exif($ph->{imgpath});

  ############################################################
  ## update marks if fig-file exists and newer then the mark file
  if ($ph->{_use_marks}) {
    ## if $opts{mark_pref} is a folder, create it
    mkdir "$imgdir$d0$opts{mark_pref}"
      if $opts{mark_pref} =~ m|/$| && ! -d "$imgdir$d0$opts{mark_pref}";
    ## if th2 file is older then the image, update it
    if (isolder($ph->{mrkpath}, $ph->{figpath})){
      print STDERR "  creating mark file: $ph->{mrkpath}\n" if $opts{verbose};

      my $sc=fig_im_scale($ph->{figpath}, $ph->{imgpath});
      die "Bad fig file: $ph->{figpath}\n" unless $sc;
      $sc*=2 if $opts{mstyle} ne 'simple_gif';

      ## create gif file
      qx* LANG="$opts{fig_lang}"\\
       fig2dev -m$sc -j -Lgif -D +0:200 -t'#FFFFFF' "$ph->{figpath}" "$ph->{mrkpath}" ||\\
         rm -f -- "$ph->{mrkpath}"*;

      ## build script for convert program
      # IE can only show transparent gifs, not png.
      # We can't use semi-transparent png here :(
      my $cmd;
      if ($opts{mstyle} eq 'simple_gif'){
      }
      elsif ($opts{mstyle} eq 'aa_gif'){
        $cmd=qq*
            ( "$ph->{imgpath}"
              ( "$ph->{mrkpath}" -alpha extract -blur 0.8 -threshold 15 -resize 50% )
              -alpha off -compose copy-opacity -composite -blur 2 )
              ( "$ph->{mrkpath}" -resize 50% )
            -compose over -composite
            "$ph->{mrkpath}"*;
      }
      elsif ($opts{mstyle} eq 'aa_gif_halo'){
        $cmd = qq*
            ( "$ph->{imgpath}"
              ( "$ph->{mrkpath}" -alpha extract -blur 1.2 -threshold 15 -resize 50% )
              +matte -compose copy-opacity -composite )
            ( "$ph->{mrkpath}"
              ( -clone 0 +matte +level-colors white.
                ( -clone 0 -alpha extract -blur 4x3 -level 0%,50% )
                -alpha off -compose copy-opacity -composite )
              -compose dst-over -composite
              -resize 50% )
            -compose over -composite
            "$ph->{mrkpath}"*;
      }
      elsif ($opts{mstyle} eq 'aa_gif_dark_halo'){
        $cmd = qq*
            ( "$ph->{imgpath}"
              ( "$ph->{mrkpath}" -alpha extract -blur 1.2 -threshold 15 -resize 50% )
              +matte -compose copy-opacity -composite )
            ( "$ph->{mrkpath}" +level 0,30%
              ( -clone 0 +matte +level-colors white
                ( -clone 0 -alpha extract -blur 4x3 -level 0%,50% )
                -alpha off -compose copy-opacity -composite )
              -compose dst-over -composite
              -resize 50% )
            -compose over -composite
            "$ph->{mrkpath}"*;
       }
#        elsif ($opts{mstyle} eq 'png_dark_halo'){
#        $cmd=qq*
#            "$ph->{mrkpath}" +level 0,30%
#            ( -clone 0 +matte +level-colors white
#              ( -clone 0 -alpha extract -blur 4x3 -level 0%,50% )
#               -alpha off -compose copy-opacity -composite )
#            -compose dst-over -composite
#            -resize 50%
#            "$ph->{mrkpath}"*;
#        }

       else{
         die "Unknown mark style: $opts{mstyle}\n";
       }
       if ($cmd){
         $cmd =~ s/([\(\)\n])/\\$1/g;
         qx"convert $cmd";
       }

    }
  }

  ############################################################
  ## Create html page if needed.
  ## We use "key" to check that html-file is up-to-date.

  # image reference for html
  my $imgref = $ph->{use_th2} ? $ph->{th2name}:$ph->{imgname};
  my $w      = $ph->{use_th2} ? $ph->{th2_w}:$ph->{img_w};
  my $h      = $ph->{use_th2} ? $ph->{th2_h}:$ph->{img_h};

  # build new key, extract old one from file
  my ($key, $oldkey) = ('','');
  if (!$opts{nohtml}){
    # make new key
    # all options which affect html pages should be here
    $key = Digest::MD5::md5_hex(join("\n",(
      $imgref, $w, $h, @files,
      $ph->{title}, $purl, $uurl, $nurl,
      ($ph->{_use_marks} ? $opts{mstyle}:''),
      $ph->{use_th1}, $ph->{use_th2},
      $opts{map_ref} || '', $opts{map_zoom},
      $opts{lang} || '',
      $opts{html_charset} || '',
      $opts{html_viewport} || '',
      $opts{html_screen_sw} || '',
      $opts{html_arrows} || '',
      $opts{html_resize} || '',
      $add{photo_head} || '',
      $add{photo_begin} || '',
      $add{photo_end} || '',
      $html_version)));
    # get old key
    if (open KEY, $ph->{htmpath}) {
      while (readline KEY){
        if (m|<!--KEY:([a-fA-F\d]*)-->|){
          $oldkey = $1 if m|<!--KEY:([a-fA-F\d]*)-->|;
          last;
        }
      }
      close KEY;
    }
  }

  if (!$opts{nohtml} && $key ne $oldkey){
    print STDERR "  creating html file: $ph->{htmpath}\n" if $opts{verbose};

    my $scr="";
    my $top="";
    my $btm="";
    my $head="";
    my $sty="";
    $head .=qq*
      <meta http-equiv="Content-Type" content="text/html; charset=$opts{html_charset}"/>*
      if $opts{html_charset};
    $head .=qq*
      <meta name="viewport" content="width=device-width, initial-scale=1.0">*
        if $opts{html_viewport};
    $head .=qq*
      <link href="$ph->{img2datadir}addphoto_photo.css" rel="stylesheet"/>*;
    $head .=qq*
      <link href="$ph->{img2datadir}addphoto_lang.css" rel="stylesheet"/>*
        if $opts{lang} eq 'select';
    $head .=qq*
      <script type="text/JavaScript" src="$ph->{img2datadir}addphoto_nav.js"></script>*
      if $opts{html_arrows};
    $head .=qq*
      <script type="text/JavaScript" src="$ph->{img2datadir}addphoto_lang.js"></script>*
      if $opts{lang} eq 'select';
    $head .=qq*
      <script type="text/JavaScript" src="$ph->{img2datadir}addphoto_marks.js"></script>*
      if $ph->{_use_marks};
    $head .=qq*
      <script type="text/JavaScript" src="$ph->{img2datadir}addphoto_multi.js"></script>*
      if $ph->{_use_multi};
    $head .=qq*
      <script type="text/JavaScript" src="$ph->{img2datadir}addphoto_fit.js"></script>*
      if $opts{html_screen_sw};

    # make language switch
    if ($opts{lang} eq 'select'){
      $top  .= qq*
      <div align=right>
        <span class="ru_control" id=lang_ru onclick="lang_set('ru')">ru</span>
        <span class="en_control" id=lang_en onclick="lang_set('en')">en</span>
      </div>*;
    }

    # make title
    if ( $ph->{title} ){
      $head .= qq*
      <title>$ph->{atitle}</title>*;
      $btm .= qq*
      <div class=addphoto-title>$ph->{title}</div>*;
    }

    # make navigation panel
    my $nav ='';
    if ( $purl || $uurl || $nurl){
      my $p = get_msg('pref');
      my $u = get_msg('uref');
      my $n = get_msg('nref');
      $p = "<a href=\"$purl\">$p</a>" if $purl;
      $u = "<a href=\"$uurl\">$u</a>" if $uurl;
      $n = "<a href=\"$nurl\">$n</a>" if $nurl;
      $nav .= qq*
      <div class=addphoto-btn>$p</div>
      <div class=addphoto-btn>$u</div>
      <div class=addphoto-btn>$n</div>*;
    }
    # navigation links in the head
    $head .= qq*
    <link rel="top" href="$uurl">* if $uurl;
    $head .= qq*
    <link rel="previous" href="$purl">* if $purl;
    $head .= qq*
    <link rel="next" href="$nurl">* if $nurl;
    $nav .= "\n    <br/>";

    # fit-to-screen button
    if ($opts{html_screen_sw}) {
      my $msg = get_msg('sw_size');
      $nav .= qq*
        <div class=addphoto-btn id=addphoto-fit-btn onclick="switch_fit()">$msg</div>*;
      $sty .= qq[
        /* fit-to-screen button */
        #addphoto-fit-btn {display: none;}
        \@media screen and (max-width: ${w}px) {
          #addphoto-fit-btn { display: inline;} }];
    }

    # switch images button
    if ($ph->{_use_multi}){
      my $msg = get_msg('sw_imgs');
      $nav .= qq*
        <div class=addphoto-btn onclick="switch_multi()">$msg</div>*;
    }

    # switch marks button
    if ($ph->{_use_marks}){
      my $msg = get_msg('sw_mark');
      $nav .= qq*
        <div class=addphoto-btn onclick="switch_mrk()">$msg</div>*;
    }

    $top .= qq*
    <div class=addphoto-nav>$nav
    </div>*;

    my $mw = $opts{html_resize} ? 'maxwidth:100%;':'';

    # main image
    my $main=qq*
        <img id=img0 class="addphoto-img0" style='width:${w}px;$mw'
           src='$imgref' alt='$ph->{atitle}'/>*;

    # marks overlay
    if ($ph->{_use_marks}){
      $main .= qq*
        <img id=marks class="addphoto-imgN" style='width:${w}px;$mw'
             src='$ph->{mrkname}'/>*;
    }

    # multiple images:
    if ($ph->{_use_multi}){
      for(my $i=1; $i<=$#files+1; $i++){
        my ($d, $b, $e) = path_split($files[$i-1]);
        $main .= qq*
          <img id="img$i" class="addphoto-imgN" style='width:${w}px;visibility:hidden;$mw'
             src='$b$e'/>*;
      }
    }

    # wrap images into a div
    $main = qq*
      <div style="position: relative;" class="clickable">$main
      </div>*;


    # info from exif
    my $exif = '';
    $exif .= "\n      <br/>" . get_msg('dat_fmt') . ' ' . $ph->{time} if $ph->{time};
    $exif .= "\n      <br/>" . get_msg('alt_fmt') . ' ' . $ph->{alt}  if $ph->{alt};
    $exif .= "\n      <br/>" . get_msg('crd_fmt') . ' ' .
       html_crd($ph->{lat}, $ph->{lon}, $ph->{imgname}) if $ph->{lat} && $ph->{lon};

    $btm .= qq*
      <div class=addphoto-info>$exif
      </div>*;

    # full size
    if ($ph->{use_th2}) {
      my $msg = get_msg('fullsize');
      $btm .= qq*
      <div class=addphoto-btn><a href="$b0$e0">[$msg]</a></div>*;
    }

    # wrap style settings
    if ($sty){
      $sty = qq*
      <style type="TEXT/CSS">$sty
      </style>*;
    }

    # write html
    open OUT, "> $ph->{htmpath}" or die "can't open $ph->{htmpath}: $!\n";
print OUT qq*<!DOCTYPE html>
<!--KEY:$key-->
<head>
$head$scr$sty
$add{photo_head}
</head>
<body>
$add{photo_begin}
$top$main$btm
$add{photo_end}
</body>
</html>
*;
    close OUT;
  }
}



#################################################################
#################################################################
### Write common files: addphoto_*.js, addphoto_*.css

open STY, "> ${datadir}addphoto_index.css" or die
  "can't open file: ${datadir}addphoto_index.css: $!\n";

my $max_width = $opts{page_width}?
  sprintf("\nmax-width:%dpx;", $opts{page_width}+50) : "";

print STY qq[
a {
  text-decoration:none;
}
body {
  background-color: white;$max_width
  margin: auto;
  padding: 20px;
}

.addphoto-caption {
  font-style:italic;
  min-height:1.5ex;
  text-align:left;
}
.addphoto-row {
  content:"";
  display:block;
  margin-left:auto;
  margin-right:auto;
  max-width:100%;
  height:auto;
  text-align:center;
}
.addphoto-img-center {
  display: inline-block;
  vertical-align: top;
  text-align: center;
  padding:2 5px;
  max-width:100%;
  height:auto;
}
.addphoto-img-left {
  display: inline-block;
  float: left;
  padding:2 5px;
  max-width:100%;
  height:auto;
}
.addphoto-img-right {
  display: inline-block;
  float: right;
  padding:2 5px;
  max-width:100%;
  height:auto;
}
.addphoto-th {
  max-width:100%;
  height:auto;
}
body
];
close STY;

if (!$opts{nohtm}){
  open STY, "> ${datadir}addphoto_photo.css" or die
    "can't open file: ${datadir}addphoto_photo.css: $!\n";
  print STY qq[
a {
  text-decoration:none;
}
body {
  background-color: white;
}

.addphoto-img0 {
  height:auto;
  position: relative;
}

.addphoto-imgN {
  height:auto;
  position: absolute; left: 0px; top: 0px;
}

.addphoto-nav {
  content:'';
  display:block;
  width:100%;
}
.addphoto-btn {
  color:blue;cursor:pointer;
  font: bold 10pt sans-serif;
  padding:2 10px;
  display:inline-block;
}
.addphoto-title {
  font: 16pt sans-serif;
  margin: 0px; padding-bottom: 20px;
  border-bottom: 1px solid #E0E0E0;
  width: 100%;
}
.addphoto-info {
  font: bold 8pt sans-serif;
}
/* marks layer */
#marks {
  position:absolute;
  left: 0px; top: 0px;
  visibility:visible;
}
];
  close STY;
}

### languge support
if ($opts{lang} eq 'select'){
  open STY, "> ${datadir}addphoto_lang.css" or die
    "can't open file: ${datadir}addphoto_lang.css: $!\n";
  print STY qq*
.ru_control,.en_control {color:blue;cursor:pointer; }
.ru {display:inline;} .en {display:none;}
*;
  close STY;

  open JS, "> ${datadir}addphoto_lang.js" or die
    "can't open file: ${datadir}addphoto_lang.js: $!\n";

  print JS qq*
  var langs=['ru', 'en'];
  // get default language
  function lang_def(){
    lvars = [window.navigator.languages, window.navigator.language, window.navigator.userLanguage]
    hasru = false;
    for (const v of lvars) { hasru ||= v && v.includes("ru"); }
    return hasru ? 'ru':'en';
  }
  // save language to storage/cookies
  function lang_save(v){
    // use storage
    if (typeof(Storage) !== "undefined") {
      localStorage.setItem("lang", v);
    }
  }
  // load language from storage/cookies
  function lang_load(){
    if (typeof(Storage) !== "undefined") {
      v = localStorage.getItem("lang");
      return v? v: lang_def();
    } else {
      return lang_def();
    }
  }
  // set language from button
  function lang_set(lang){
    lang_save(lang);
    for (var i=0; i<langs.length; i++){
      document.getElementById("lang_"+langs[i]).style.fontWeight=
        (langs[i]==lang) ? 'bold':'normal';
      var els=document.getElementsByClassName(langs[i]);
      for (var j=0; j<els.length; j++){
        els[j].style.display = (langs[i]==lang) ? 'inline':'none'; }
    }
  }
  // set language after loading document
  function lang_init(){
    var urlParams = new URLSearchParams(window.location.search);
    var l = urlParams.get('lang');
    if (l==null) l=lang_load()
    lang_set(l);
  }

  // switch language
  function lang_sw(){ lang_set(lang_load()=='ru'? 'en':'ru'); }

  // switch language with 't' key
  function lang_key(event){ if (event.code == 'KeyT'){lang_sw();} }
  window.addEventListener('keydown', lang_key);
  window.addEventListener('load', lang_init);
*;
  close JS;
}

### switching marks
if (!$opts{nohtml} && $opts{_use_marks}) {
  open JS, "> ${datadir}addphoto_marks.js" or die
    "can't open file: ${datadir}addphoto_marks.js: $!\n";
  print JS qq*
  // switch image marks
  function switch_mrk(){
    var e = document.getElementById("marks");
    if (!marks) {return;}
    e.style.visibility = e.style.visibility=='hidden' ? 'visible':'hidden';
  }
  // switch marks with 'm' key
  function mark_key(event){
    if (event.code == 'Enter' || event.code == 'KeyM'){ switch_mrk(); }
  }
  window.addEventListener('keydown', mark_key);
*;
  close JS;
}

### fit-to-screen switch
if (!$opts{nohtml} && $opts{html_screen_sw}) {
  open JS, "> ${datadir}addphoto_fit.js" or die
    "can't open file: ${datadir}addphoto_fit.js: $!\n";
  print JS qq*
  // fit-to-screen switch
  function switch_fit(){
    for (img of document.getElementsByClassName("addphoto-img0 addphoto-imgN")){
      img.style.maxWidth = getComputedStyle(img).maxWidth == '100%'? null:'100%';
    }
  }
  // switch and scroll on click
  function click_fit(event){
    var img0 = document.getElementById("img0");
    var w1 = img0.width;
    var h1 = img0.height;
    var xs = window.scrollX;
    var ys = window.scrollY;
    var x0 = img0.getBoundingClientRect().left + xs;
    var y0 = img0.getBoundingClientRect().top + ys;
    switch_fit();
    var w2 = img0.width;
    var h2 = img0.height;
    var kx = 1.0\*w2/w1;
    var ky = 1.0\*h2/h1;
    var xm  = event.clientX;
    var ym  = event.clientY;
    window.scroll(x0-xm + kx\*(xs-x0+xm), y0-ym + ky\*(ys-y0+ym));
  }
  function set_click(){
    for (i of document.getElementsByClassName("clickable")){
      i.addEventListener('click', click_fit); } }
  window.addEventListener('load', set_click);
  // switch on S key
  function fit_key(event){ if (event.code == 'KeyS'){ switch_fit(); }}
  window.addEventListener('keydown', fit_key);
*;
  close JS;
}


if (!$opts{nohtml} && $opts{html_arrows}) {
  open JS, "> ${datadir}addphoto_nav.js" or die
    "can't open file: ${datadir}addphoto_nav.js: $!\n";

  print JS qq*
  // key navigation
  function nav_key(event){

    var rel = "";
    if (event.ctrlKey && event.code == 'ArrowRight'){
      rel = "next";
    }
    else if (event.ctrlKey && event.code == 'ArrowLeft'){
      rel = "previous";
    }
    else if (event.code == 'Escape'){
      rel = "top";
    }
    if (rel == "") return;

    var links = document.getElementsByTagName("link");
    for (var i = 0; i < links.length; i++) {
      if (links[i].rel != rel) continue;
      event.preventDefault();
      event.stopPropagation();
      window.location.href = links[i].href;
      return;
    }
  }
  window.addEventListener('keydown', nav_key);
*;
  close JS;
}

if (!$opts{nohtml} && $opts{_use_multi}) {
  open JS, "> ${datadir}addphoto_multi.js" or die
    "can't open file: ${datadir}addphoto_multi.js: $!\n";

  print JS qq*
  // switch multiple images
  var nv = 0;
  function switch_multi(){
    nn=document.getElementsByClassName('addphoto-imgN').length + 1;
    nv=(nv+1)\%nn;
    for (var i=1;i<nn;i++){
      document.getElementById("img"+i).style.visibility=
        i<=nv?'visible':'hidden'}}
  function multi_key(event){
    if (event.code == 'KeyI'){ switch_multi(); }}
  window.addEventListener('keydown', multi_key);
*;
  close JS;
}



#################################################################
#################################################################
### create main html
my $in_row=0;
my $np=0;
my $nh=0;

my $html = $opts{html_stdout} ? '/dev/stdout' : $src_dir.$opts{html};

if ($opts{html_filter}){
  open OUT, "|-", "$opts{html_filter} > $html"
    or die "Can't open $opts{html_filter} > $html: $!\n";
}
else {
  open OUT, ">", "$html"
    or die "Can't open $html: $!\n";
}
print STDERR "[Creating HTML page: $html]\n" if $opts{verbose};


# print html header
if ($opts{html_headers}) {
  print OUT qq*<!DOCTYPE html>
<!-- Created by addphoto https://github.com/slazav/addphoto -->
<html>
<head>*;

  print OUT qq*
  <meta http-equiv="Content-Type" content="text/html; charset=$opts{html_charset}"/>*
    if $opts{html_charset};

  print OUT qq*
  <meta name="viewport" content="width=device-width, initial-scale=1.0">*
    if $opts{html_viewport};

  print OUT qq*
  <link href="$opts{datadir}addphoto_index.css" rel="stylesheet"/>*;

  print OUT qq*
  <link href="$opts{datadir}addphoto_lang.css" rel="stylesheet"/>
  <script type="text/JavaScript" src="$opts{datadir}addphoto_lang.js"></script>*
    if $opts{lang} eq 'select';

  print OUT qq*
$add{head}
</head>
<body>*;

  print OUT qq*
<div align=right>
  <span class="ru_control" id=lang_ru onclick="lang_set('ru')">ru</span>
  <span class="en_control" id=lang_en onclick="lang_set('en')">en</span>
</div>* if $opts{lang} eq 'select';

  print OUT qq*
$add{begin}*;
}

foreach my $b (@data){
  if ($b->{type} eq 'photo') {
    $np++;
    my ($img, $title) = (${$b->{files}}[0], $b->{title});

    # paths from html index
    my $htm2img = $opts{imgdir} . $b->{imgdir2img};
    my $imgfile = $htm2img . $b->{imgname};
    my $htmfile = $htm2img . $b->{htmname};
    my $th1file = $htm2img . $b->{th1name};
    my $th2file = $htm2img . $b->{th2name};
    my $mrkfile = $htm2img . $b->{mrkname};
    # what to use in the index:
    my $th_file = $b->{use_th1} ? $th1file : ($b->{use_th2} ? $th2file : $imgfile);

    # get size of small thumbnail (it can be missing if use_th1==0!)
    unless ($b->{th1_w} && $b->{th1_h}) {
      my $ret;
      ($ret, $b->{th1_w}, $b->{th1_h}) =
      split(/\s+/, `$opts{ph_resize} --scale "$opts{th1_size}" --dryrun --printres "$b->{imgpath}" /dev/null`);
    }

    # start a new row only if align = center
    if ($b->{align} eq 'center') {
      print OUT "<div class=addphoto-row>\n" unless $in_row;
      $in_row=1;
    } else {
      print OUT "</div>\n" if $in_row; # close row
      $in_row=0;
    }
    my $a_attrs=" name='ph$np'";
    if ($opts{nohtml}) { $a_attrs .= " href='$imgfile'"; }
    else               { $a_attrs .= " href='$htmfile'"; }
    print OUT "<div class=addphoto-img-$b->{align}><a$a_attrs>\n";
    print OUT "<img src='$th_file' alt='$b->{atitle}'" .
              " width=$b->{th1_w} height=$b->{th1_h}".
              " class=addphoto-th/></a>\n";
    print OUT "<br/><div class=addphoto-caption style='width:$b->{th1_w}px'>$b->{title}</div>\n";
    print OUT "</div>\n";
  }
  else{
    print OUT "</div>\n" if $in_row; # close row
    $in_row=0;
    if ($b->{type} eq 'head'){ # \h commands
      $nh++;
      my ($depth, $title, $ruler) = ($b->{depth}, $b->{title}, $b->{ruler});
      print OUT ($ruler?'<hr>':'') .
        "<a name='h$nh'></a><h$depth>$title</h$depth>\n";
      next;
    }
    if ($b->{type} eq 'toc'){
      html_toc(*OUT, \@data);
      next;
    }
    if ($b->{type} eq 'text' && $b->{ctx} eq ''){
      print OUT $b->{text};
      next;
    }
    if ($b->{type} eq 'ref'){
      if (not exists $index{$b->{name}}){
        # try to find and read index file
        my ($ref_dir, $ref_base, $ref_ext) = path_split($b->{name});
        read_index($ref_dir);
      }
      if (not exists $index{$b->{name}}){
        warn "skipping \\ref command: unknown index key: $b->{name}\n";
        next;
      }
      my $e = expand($index{$b->{name}}, $b->{text}, '@');
      print OUT expand1($e), "\n";
      next;
    }
  }
}
print OUT "</div>\n" if $in_row; # close row

# print html tail
print OUT qq*
$add{end}
</body>
</html>
* if $opts{html_headers};

close OUT;

print STDERR "[Done: $np photos, $nh headers]\n" if $opts{verbose};
